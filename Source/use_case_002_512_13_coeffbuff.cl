int rem(int x, int y)
{
    return (x % y + y) % y;
}

__kernel
void fdtdKernel(__global int* idGrid, __global float* modelGrid, __global float* boundaryGrid, int idxRotate, int idxSample, __global float* input, __global float* output, __global int* inputPosition, __global int* outputPosition, __global float* coeffBuff, int bufferLength)
{
    if(get_global_id(0) == 0 || get_global_id(1) == 0 || get_global_id(0) == get_global_size(0) || get_global_id(1) == get_global_size(1) || get_global_id(0) == 1 || get_global_id(0) == get_global_size(0)-1 || get_global_id(1) == 1 || get_global_id(1) == get_global_size(1)-1 )
		return;

	//Rotation Index into model grid//
	int gridSize = get_global_size(0) * get_global_size(1);
    
	int rotation0 = gridSize * rem(idxRotate+0, 3);
	int rotationM1 = gridSize * rem(idxRotate+-1, 3);
	int rotation1 = gridSize * rem(idxRotate+1, 3);
	
    
	//Get index for current and neighbouring nodes//
	int t0x0y0Idx = rotation0 + ((get_global_id(1)+0) * get_global_size(0) + get_global_id(0)+0);
	int t0x1y0Idx = rotation0 + ((get_global_id(1)+1) * get_global_size(0) + get_global_id(0)+0);
	int t0xM1y0Idx = rotation0 + ((get_global_id(1)+-1) * get_global_size(0) + get_global_id(0)+0);
	int t0x0y1Idx = rotation0 + ((get_global_id(1)+0) * get_global_size(0) + get_global_id(0)+1);
	int t0x0yM1Idx = rotation0 + ((get_global_id(1)+0) * get_global_size(0) + get_global_id(0)+-1);
	int t0x1y1Idx = rotation0 + ((get_global_id(1)+1) * get_global_size(0) + get_global_id(0)+1);
	int t0xM1yM1Idx = rotation0 + ((get_global_id(1)+-1) * get_global_size(0) + get_global_id(0)+-1);
	int t0x1yM1Idx = rotation0 + ((get_global_id(1)+1) * get_global_size(0) + get_global_id(0)+-1);
	int t0xM1y1Idx = rotation0 + ((get_global_id(1)+-1) * get_global_size(0) + get_global_id(0)+1);
	int t0x2y0Idx = rotation0 + ((get_global_id(1)+2) * get_global_size(0) + get_global_id(0)+0);
	int t0xM2y0Idx = rotation0 + ((get_global_id(1)+-2) * get_global_size(0) + get_global_id(0)+0);
	int t0x0y2Idx = rotation0 + ((get_global_id(1)+0) * get_global_size(0) + get_global_id(0)+2);
	int t0x0yM2Idx = rotation0 + ((get_global_id(1)+0) * get_global_size(0) + get_global_id(0)+-2);
	int tM1x0y0Idx = rotationM1 + ((get_global_id(1)+0) * get_global_size(0) + get_global_id(0)+0);
	int tM1x1y0Idx = rotationM1 + ((get_global_id(1)+1) * get_global_size(0) + get_global_id(0)+0);
	int tM1xM1y0Idx = rotationM1 + ((get_global_id(1)+-1) * get_global_size(0) + get_global_id(0)+0);
	int tM1x0y1Idx = rotationM1 + ((get_global_id(1)+0) * get_global_size(0) + get_global_id(0)+1);
	int tM1x0yM1Idx = rotationM1 + ((get_global_id(1)+0) * get_global_size(0) + get_global_id(0)+-1);
	
	int t1x0y0Idx = rotation1 + ((get_global_id(1)) * get_global_size(0) + get_global_id(0));

	//Boundary condition evaluates neighbours in preperation for equation//
	//@ToDo - Make new timestep value autogenerated?//
	float t1x0y0;
	float t0x0y0;
	float t0x1y0;
	float t0xM1y0;
	float t0x0y1;
	float t0x0yM1;
	float t0x1y1;
	float t0xM1yM1;
	float t0x1yM1;
	float t0xM1y1;
	float t0x2y0;
	float t0xM2y0;
	float t0x0y2;
	float t0x0yM2;
	float tM1x0y0;
	float tM1x1y0;
	float tM1xM1y0;
	float tM1x0y1;
	float tM1x0yM1;
	
	tM1x0y0 = modelGrid[tM1x0y0Idx];
	t0x0y0 = modelGrid[t0x0y0Idx];
	

	int centreIdx = (get_global_id(1)) * get_global_size(0) + get_global_id(0);
    int leftIdx = (get_global_id(1)-1) * get_global_size(0) + get_global_id(0);
    int rightIdx = (get_global_id(1)-1) * get_global_size(0) + get_global_id(0);
    int upIdx = (get_global_id(1)) * get_global_size(0) + get_global_id(0)-1;
    int downIdx = (get_global_id(1)) * get_global_size(0) + get_global_id(0)+1;

    int leftLeftIdx = (get_global_id(1)-2) * get_global_size(0) + get_global_id(0);
    int rightRightIdx = (get_global_id(1)+2) * get_global_size(0) + get_global_id(0);
    int upUpIdx = (get_global_id(1)) * get_global_size(0) + get_global_id(0)-2;
    int downDownIdx = (get_global_id(1)) * get_global_size(0) + get_global_id(0)+2;

    int leftUpIdx = (get_global_id(1)-1) * get_global_size(0) + get_global_id(0)-1;
    int rightUpIdx = (get_global_id(1)+1) * get_global_size(0) + get_global_id(0)-1;
    int leftDownIdx = (get_global_id(1)-1) * get_global_size(0) + get_global_id(0)+1;
    int rightDownIdx = (get_global_id(1)+1) * get_global_size(0) + get_global_id(0)+1;

    // Hybird Boundary?
    // t0x0yM1 = modelGrid[t0x0yM1Idx] * (1-boundaryGrid[upIdx]) +  modelGrid[centreIdx] * (boundaryGrid[upIdx]);
    // t0x1y0 = modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]) +  modelGrid[centreIdx] * (boundaryGrid[rightIdx]);
    // t0x0y1 = modelGrid[t0x0y1Idx]* (1-boundaryGrid[downIdx]) +  modelGrid[centreIdx] * (boundaryGrid[downIdx]);
    // t0xM1y0 = modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx])+  modelGrid[centreIdx] * (boundaryGrid[leftIdx]);

    // t0x1y1 = modelGrid[t0x1y1Idx]* (1-boundaryGrid[rightDownIdx])+  modelGrid[centreIdx] * (boundaryGrid[rightDownIdx]);
    // t0x1yM1 = modelGrid[t0x1yM1Idx]* (1-boundaryGrid[rightUpIdx])+  modelGrid[centreIdx] * (boundaryGrid[rightUpIdx]);
    // t0xM1y1 = modelGrid[t0xM1y1Idx]* (1-boundaryGrid[leftDownIdx])+  modelGrid[centreIdx] * (boundaryGrid[leftDownIdx]);
    // t0xM1yM1 = modelGrid[t0xM1yM1Idx]* (1-boundaryGrid[leftUpIdx])+  modelGrid[centreIdx] * (boundaryGrid[leftUpIdx]);

    // t0x0y2 = modelGrid[t0x0y2Idx]* (1-boundaryGrid[downDownIdx])+  modelGrid[centreIdx] * (boundaryGrid[downDownIdx]);
    // t0x2y0 = modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx])+  modelGrid[centreIdx] * (boundaryGrid[rightRightIdx]);
    // t0xM2y0 = modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx])+  modelGrid[centreIdx] * (boundaryGrid[leftLeftIdx]);
    // t0x0yM2 = modelGrid[t0x0yM2Idx]* (1-boundaryGrid[upUpIdx])+  modelGrid[centreIdx] * (boundaryGrid[upUpIdx]);

    // tM1x1y0 = modelGrid[tM1x1y0Idx]* (1-boundaryGrid[rightIdx])+  modelGrid[centreIdx] * (boundaryGrid[downIdx]);
    // tM1xM1y0 = modelGrid[tM1xM1y0Idx]* (1-boundaryGrid[leftIdx])+  modelGrid[centreIdx] * (boundaryGrid[downIdx]);
    // tM1x0y1 = modelGrid[tM1x0y1Idx]* (1-boundaryGrid[downIdx])+  modelGrid[centreIdx] * (boundaryGrid[downIdx]);
    // tM1x0yM1 = modelGrid[tM1x0yM1Idx]* (1-boundaryGrid[upIdx])+  modelGrid[centreIdx] * (boundaryGrid[downIdx]);

    // Dirichlet Boundary?
    // t0x0yM1 = modelGrid[t0x0yM1Idx] * (1-boundaryGrid[upIdx]);
    // t0x1y0 = modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]);
    // t0x0y1 = modelGrid[t0x0y1Idx]* (1-boundaryGrid[downIdx]);
    // t0xM1y0 = modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx]);

    // t0x1y1 = modelGrid[t0x1y1Idx]* (1-boundaryGrid[rightDownIdx]);
    // t0x1yM1 = modelGrid[t0x1yM1Idx]* (1-boundaryGrid[rightUpIdx]);
    // t0xM1y1 = modelGrid[t0xM1y1Idx]* (1-boundaryGrid[leftDownIdx]);
    // t0xM1yM1 = modelGrid[t0xM1yM1Idx]* (1-boundaryGrid[leftUpIdx]);

    // t0x0y2 = modelGrid[t0x0y2Idx]* (1-boundaryGrid[downDownIdx]);
    // t0x2y0 = modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx]);
    // t0xM2y0 = modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx]);
    // t0x0yM2 = modelGrid[t0x0yM2Idx]* (1-boundaryGrid[upUpIdx]);

    // tM1x1y0 = modelGrid[tM1x1y0Idx]* (1-boundaryGrid[rightIdx]);
    // tM1xM1y0 = modelGrid[tM1xM1y0Idx]* (1-boundaryGrid[leftIdx]);
    // tM1x0y1 = modelGrid[tM1x0y1Idx]* (1-boundaryGrid[downIdx]);
    // tM1x0yM1 = modelGrid[tM1x0yM1Idx]* (1-boundaryGrid[upIdx]);

    // No boundary
    t0xM2y0 = modelGrid[t0xM2y0Idx];
    t0x0y2 = modelGrid[t0x0y2Idx];
    t0x0yM2 = modelGrid[t0x0yM2Idx];
    tM1x1y0 = modelGrid[tM1x1y0Idx];
    tM1xM1y0 = modelGrid[tM1xM1y0Idx];
    tM1x0y1 = modelGrid[tM1x0y1Idx];
    tM1x0yM1 = modelGrid[tM1x0yM1Idx];
    t0x0y1 = modelGrid[t0x0y1Idx];
    t0x1y0 = modelGrid[t0x1y0Idx];
    t0xM1y0 = modelGrid[t0xM1y0Idx];
    t0x0yM1 = modelGrid[t0x0yM1Idx];
    t0x1y1 = modelGrid[t0x1y1Idx];
    t0xM1yM1 = modelGrid[t0xM1yM1Idx];
    t0x1yM1 = modelGrid[t0x1yM1Idx];
    t0xM1y1 = modelGrid[t0xM1y1Idx];
    t0x2y0 = modelGrid[t0x2y0Idx];
	
	//Calculate the next pressure value//
	if(idGrid[centreIdx] == 0)
{t1x0y0 = 0.0;}
if(idGrid[centreIdx] == 1) {
		t1x0y0 = ((coeffBuff[0]*modelGrid[t0x0y0Idx])
        + (coeffBuff[1]*(modelGrid[t0x1y0Idx]+modelGrid[t0xM1y0Idx]+modelGrid[t0x0y1Idx]+modelGrid[t0x0yM1Idx]))
        - (coeffBuff[2]*(modelGrid[t0x1y1Idx]+modelGrid[t0xM1yM1Idx]+modelGrid[t0x1yM1Idx]+modelGrid[t0xM1y1Idx]))
        - (coeffBuff[3]*(modelGrid[t0x2y0Idx]+modelGrid[t0xM2y0Idx]+modelGrid[t0x0y2Idx]+modelGrid[t0x0yM2Idx]))
        + (coeffBuff[4]*modelGrid[tM1x0y0Idx])
        - (coeffBuff[5]*(modelGrid[tM1x1y0Idx]+modelGrid[tM1xM1y0Idx]+modelGrid[tM1x0y1Idx]+modelGrid[tM1x0yM1Idx]))
        + (input[idxSample] * inputPosition[centreIdx]))
        / coeffBuff[6];
}
if(idGrid[centreIdx] == 2) {
		t1x0y0 = ((coeffBuff[7]*modelGrid[t0x0y0Idx])
        +(coeffBuff[8]*((modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]))+(modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        -(coeffBuff[9]*((modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx]))+(modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx]))))
        +(coeffBuff[10]*modelGrid[tM1x0y0Idx])
        -(coeffBuff[11]*((modelGrid[tM1x1y0Idx]* (1-boundaryGrid[rightIdx]))+(modelGrid[tM1xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        + (input[idxSample] * inputPosition[centreIdx])) / coeffBuff[12];
}
if(idGrid[centreIdx] == 3) {
    t1x0y0 = ((coeffBuff[13]*modelGrid[t0x0y0Idx])
        +(coeffBuff[14]*((modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]))+(modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        -(coeffBuff[15]*((modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx]))+(modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx]))))
        +(coeffBuff[16]*modelGrid[tM1x0y0Idx])
        -(coeffBuff[17]*((modelGrid[tM1x1y0Idx]* (1-boundaryGrid[rightIdx]))+(modelGrid[tM1xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        + (input[idxSample] * inputPosition[centreIdx])) / coeffBuff[18];
}
if(idGrid[centreIdx] == 4) {
    t1x0y0 = ((coeffBuff[19]*modelGrid[t0x0y0Idx])
        +(coeffBuff[20]*((modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]))+(modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        -(coeffBuff[21]*((modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx]))+(modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx]))))
        +(coeffBuff[22]*modelGrid[tM1x0y0Idx])
        -(coeffBuff[23]*((modelGrid[tM1x1y0Idx]* (1-boundaryGrid[rightIdx]))+(modelGrid[tM1xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        + (input[idxSample] * inputPosition[centreIdx])) / coeffBuff[24];
}
if(idGrid[centreIdx] == 5) {
    t1x0y0 = ((coeffBuff[25]*modelGrid[t0x0y0Idx])
        +(coeffBuff[26]*((modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]))+(modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        -(coeffBuff[27]*((modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx]))+(modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx]))))
        +(coeffBuff[28]*modelGrid[tM1x0y0Idx])
        -(coeffBuff[29]*((modelGrid[tM1x1y0Idx]* (1-boundaryGrid[rightIdx]))+(modelGrid[tM1xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        + (input[idxSample] * inputPosition[centreIdx])) / coeffBuff[30];
}
if(idGrid[centreIdx] == 6) {
    t1x0y0 = ((coeffBuff[31]*modelGrid[t0x0y0Idx])
        +(coeffBuff[32]*((modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]))+(modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        -(coeffBuff[33]*((modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx]))+(modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx]))))
        +(coeffBuff[34]*modelGrid[tM1x0y0Idx])
        -(coeffBuff[35]*((modelGrid[tM1x1y0Idx]* (1-boundaryGrid[rightIdx]))+(modelGrid[tM1xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        + (input[idxSample] * inputPosition[centreIdx])) / coeffBuff[36];
}
if(idGrid[centreIdx] == 7) {
    t1x0y0 = ((coeffBuff[37]*modelGrid[t0x0y0Idx])
        +(coeffBuff[38]*((modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]))+(modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        -(coeffBuff[39]*((modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx]))+(modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx]))))
        +(coeffBuff[40]*modelGrid[tM1x0y0Idx])
        -(coeffBuff[41]*((modelGrid[tM1x1y0Idx]* (1-boundaryGrid[rightIdx]))+(modelGrid[tM1xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        + (input[idxSample] * inputPosition[centreIdx])) / coeffBuff[42];
}
if(idGrid[centreIdx] == 8) {
    t1x0y0 = ((coeffBuff[43]*modelGrid[t0x0y0Idx])
        +(coeffBuff[44]*((modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]))+(modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        -(coeffBuff[45]*((modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx]))+(modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx]))))
        +(coeffBuff[46]*modelGrid[tM1x0y0Idx])
        -(coeffBuff[47]*((modelGrid[tM1x1y0Idx]* (1-boundaryGrid[rightIdx]))+(modelGrid[tM1xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        + (input[idxSample] * inputPosition[centreIdx])) / coeffBuff[48];
}
if(idGrid[centreIdx] == 9) {
    t1x0y0 = ((coeffBuff[49]*modelGrid[t0x0y0Idx])
        +(coeffBuff[50]*((modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]))+(modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        -(coeffBuff[51]*((modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx]))+(modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx]))))
        +(coeffBuff[52]*modelGrid[tM1x0y0Idx])
        -(coeffBuff[53]*((modelGrid[tM1x1y0Idx]* (1-boundaryGrid[rightIdx]))+(modelGrid[tM1xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        + (input[idxSample] * inputPosition[centreIdx])) / coeffBuff[54];
}
if(idGrid[centreIdx] == 10) {
    t1x0y0 = ((coeffBuff[55]*modelGrid[t0x0y0Idx])
        +(coeffBuff[56]*((modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]))+(modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        -(coeffBuff[57]*((modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx]))+(modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx]))))
        +(coeffBuff[58]*modelGrid[tM1x0y0Idx])
        -(coeffBuff[59]*((modelGrid[tM1x1y0Idx]* (1-boundaryGrid[rightIdx]))+(modelGrid[tM1xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        + (input[idxSample] * inputPosition[centreIdx])) / coeffBuff[60];
}
if(idGrid[centreIdx] == 11) {
    t1x0y0 = ((coeffBuff[61]*modelGrid[t0x0y0Idx])
        +(coeffBuff[62]*((modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]))+(modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        -(coeffBuff[63]*((modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx]))+(modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx]))))
        +(coeffBuff[64]*modelGrid[tM1x0y0Idx])
        -(coeffBuff[65]*((modelGrid[tM1x1y0Idx]* (1-boundaryGrid[rightIdx]))+(modelGrid[tM1xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        + (input[idxSample] * inputPosition[centreIdx])) / coeffBuff[66];
}
if(idGrid[centreIdx] == 12) {
    t1x0y0 = ((coeffBuff[67]*modelGrid[t0x0y0Idx])
        +(coeffBuff[68]*((modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]))+(modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        -(coeffBuff[69]*((modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx]))+(modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx]))))
        +(coeffBuff[70]*modelGrid[tM1x0y0Idx])
        -(coeffBuff[71]*((modelGrid[tM1x1y0Idx]* (1-boundaryGrid[rightIdx]))+(modelGrid[tM1xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        + (input[idxSample] * inputPosition[centreIdx])) / coeffBuff[72];
}
if(idGrid[centreIdx] == 13) {
    t1x0y0 = ((coeffBuff[73]*modelGrid[t0x0y0Idx])
        +(coeffBuff[74]*((modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]))+(modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        -(coeffBuff[75]*((modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx]))+(modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx]))))
        +(coeffBuff[76]*modelGrid[tM1x0y0Idx])
        -(coeffBuff[77]*((modelGrid[tM1x1y0Idx]* (1-boundaryGrid[rightIdx]))+(modelGrid[tM1xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        + (input[idxSample] * inputPosition[centreIdx])) / coeffBuff[78];
}
if(idGrid[centreIdx] == 14) {
    t1x0y0 = ((coeffBuff[79]*modelGrid[t0x0y0Idx])
        +(coeffBuff[80]*((modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]))+(modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        -(coeffBuff[81]*((modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx]))+(modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx]))))
        +(coeffBuff[82]*modelGrid[tM1x0y0Idx])
        -(coeffBuff[83]*((modelGrid[tM1x1y0Idx]* (1-boundaryGrid[rightIdx]))+(modelGrid[tM1xM1y0Idx]* (1-boundaryGrid[leftIdx]))))
        + (input[idxSample] * inputPosition[centreIdx])) / coeffBuff[84];
}
	
	//If the cell is the listener position, sets the next sound sample in buffer to value contained here//
	if(outputPosition[centreIdx] > 0)
	{
        int outputOffset = outputPosition[centreIdx]-1;
		output[bufferLength*outputOffset+idxSample] = t0x0y0;    //@ToDo - Make current timestep centre point auto generated?
	}

    // if(t1x0y0 > 1.0)
    // {
    //     t1x0y0 = 1.0;
    // }
    // if(t1x0y0 < -1.0)
    // {
    //     t1x0y0 = -1.0;
    // }
	
	modelGrid[t1x0y0Idx] = t1x0y0;
}

__kernel
void connectionsKernel(__global int* idGrid, __global float* modelGrid, __global float* boundaryGrid, int idxRotate, int numConnections, __global int* connections, float plateDeltaH, float strDeltaH, float deltaT)
{
    //Rotation Index into model grid//
	int gridSize = get_global_size(0) * get_global_size(1);
    
	int rotation0 = gridSize * rem(idxRotate+0, 3);
	int rotationM1 = gridSize * rem(idxRotate+-1, 3);
	int rotation1 = gridSize * rem(idxRotate+1, 3);

    int centreIdx = (get_global_id(1)) * get_global_size(0) + get_global_id(0);
    int t0x0y0Idx = rotation0 + ((get_global_id(1)+0) * get_global_size(0) + get_global_id(0)+0);
    int t1x0y0Idx = rotation1 + ((get_global_id(1)) * get_global_size(0) + get_global_id(0));

    if(connections[centreIdx] > 0)
    {
        // float u = modelGrid[t0x0y0Idx];                                                                     //u=plate
        // float v = modelGrid[rotation0 + connections[centreIdx]];                                            //v=string
        // float intermediateForce = (v - u) / ((1/(plateDeltaH*plateDeltaH)) + (1/(strDeltaH)));


        // float intermediatePlate = (deltaT * deltaT * intermediateForce) / (plateDeltaH*plateDeltaH);
        // float intermediateString = (deltaT * deltaT * intermediateForce) / (strDeltaH);
        // //float intermediatePlate = (intermediateForce) / (plateDeltaH*plateDeltaH);
        // //float intermediateString = (intermediateForce) / (strDeltaH);

        // modelGrid[t1x0y0Idx] += intermediatePlate;      
        // modelGrid[rotation1 + connections[centreIdx]] -= intermediateString;

            float intermediateOne = (modelGrid[t1x0y0Idx] - modelGrid[rotation1 + connections[centreIdx]]);

            modelGrid[t1x0y0Idx] -= intermediateOne / 100;
            modelGrid[rotation1 + connections[centreIdx]] += intermediateOne / 1;
    }

    // for(int i = 0; i < numConnections; ++i)
    // {
    //     if(centreIdx == connections[i+1])
    //     {
    //         float intermediateOne = (modelGrid[t1x0y0Idx] - modelGrid[rotation1 + connections[i]]) / 100.0;
    //         float intermediateTwo = (modelGrid[t1x0y0Idx] - modelGrid[rotation1 + connections[i]]) / 100.0;

    //         modelGrid[t1x0y0Idx] += intermediateOne;
    //         modelGrid[rotation1 + connections[i]] -= intermediateTwo;
    //     }
    //     ++i;
    // }
}